1.1) Introdução: apenas apresentação do curso.

1.2) Eu já faço testes ou será que não: uma explicação geral sobre TDD e testes.

1.3) Tipos de testes automatizados: vemos vários tipos de testes. O primeiro é o teste de unidade. Um exemplo de ferramenta é o JUnit. Este teste foca em uma única classe ou método de cada vez. Já os testes de integração, como o encontrado em dbunit.sourceforge.net , verificam a integração com bancos de dados. Outro tipo é o teste de aceitação, e um exemplo está em www.seleniumhq.org. Ele faz testes de tela (interface do usuário). Também existem os testes de carga como o jmeter.apache.org.

1.4) A importância do teste de unidade: além da melhor organização do código em geral e de garantir seu funcionamento, uma grande vantagem é a documentação do código oferecida pela leitura dos testes. Há vários benefícios como desacoplar as classes dos métodos e tornar o código mais profissional.

1.5) Usando o JUnit para seu primeiro teste: criamos então um teste em JUnit. Para isso criamos um novo projeto Java no STS chamado camel-case-1 com Java 8. Depois de clicar no next adicionamos a biblioteca do JUnit versão 4. Criamos também uma nova pasta chamada test. Dentro do projeto, na pasta test criamos uma classe CamelCaseConverterTest no pacote default. Para abrir um novo teste é possível digitar test e apertar control espaço para já fazer as importações necessárias e inclusive incluir um primeiro método. Criamos então o método deveCriarObjetoCamelCaseConverter e dentro dele instanciamos a variável camelCase do tipo CamelCaseConverter. Fazemos o teste com JUnit e tudo certo. Criamos então segundo método deveConverterNomeSimples, instanciamos a variável camelCase como no primeiro teste e abrimos um Assert.assertEquals para testar "Lionel" contra "lionel" pelo método  camelCase.converter. Fazemos um import estático do assertEquals com control M. Precisamos criar o método converter e para isso clicamos em cima do nome e apertamos control 1. O método tem um atributo nome do tipo String e para o teste dar certo podemos simplesmente colocar o retorno desejado. Mas uma forma melhor de fazer isso é montar a string usando o método substring. O método substring funciona com o valor de início (zero indica o primeiro caractere) e o valor de limitação de caracteres. Caso o valor de limitação não seja usado a substring conterá todos os caracteres após a posição indicada. E para deixar o código mais eficaz, usamos uma anotação before para conter a instanciação da variável que é usada nos dois testes, depois de declará-la no início da classe. Aproveitamos para apagar o primeiro teste porque ele já não faz mais nada. Testamos e tudo funciona. Forçamos um erro criando então um novo teste deveConverterNomeSimplesMisturadoMaiusculoEMinusculo com a mesma declaração do teste anterior mas alterando a escrita no método converter para "lIOnel". Para consertar basta acrescentar o método .toLowerCase() no final do método converter na classe CamelCaseConverter.
Criamos então um novo projeto camel-case-2 usando o Maven. Nas configurações escolhemos a opção para criar um projeto simples e apertamos next. O Group Id é com.gft e o Artifact Id é camel-case-2. A versão é 1.0.0 - snapshot. O packaging fica jar mesmo. Abrimos então o pom.xml e acrescentamos as propriedades e plugins necessários. E assim temos duas formas de começar o projeto com testes.

2.1) Como começou o TDD: http://wiki.c2.com/?TenYearsOfTestDrivenDevelopment
