1.1) Introdução: apenas apresentação do curso.

1.2) Eu já faço testes ou será que não: uma explicação geral sobre TDD e testes.

1.3) Tipos de testes automatizados: vemos vários tipos de testes. O primeiro é o teste de unidade. Um exemplo de ferramenta é o JUnit. Este teste foca em uma única classe ou método de cada vez. Já os testes de integração, como o encontrado em dbunit.sourceforge.net , verificam a integração com bancos de dados. Outro tipo é o teste de aceitação, e um exemplo está em www.seleniumhq.org. Ele faz testes de tela (interface do usuário). Também existem os testes de carga como o jmeter.apache.org.

1.4) A importância do teste de unidade: além da melhor organização do código em geral e de garantir seu funcionamento, uma grande vantagem é a documentação do código oferecida pela leitura dos testes. Há vários benefícios como desacoplar as classes dos métodos e tornar o código mais profissional.

1.5) Usando o JUnit para seu primeiro teste: criamos então um teste em JUnit. Para isso criamos um novo projeto Java no STS chamado camel-case-1 com Java 8. Depois de clicar no next adicionamos a biblioteca do JUnit versão 4. Criamos também uma nova pasta chamada test. Dentro do projeto, na pasta test criamos uma classe CamelCaseConverterTest no pacote default. Para abrir um novo teste é possível digitar test e apertar control espaço para já fazer as importações necessárias e inclusive incluir um primeiro método. Criamos então o método deveCriarObjetoCamelCaseConverter e dentro dele instanciamos a variável camelCase do tipo CamelCaseConverter. Fazemos o teste com JUnit e tudo certo. Criamos então segundo método deveConverterNomeSimples, instanciamos a variável camelCase como no primeiro teste e abrimos um Assert.assertEquals para testar "Lionel" contra "lionel" pelo método  camelCase.converter. Fazemos um import estático do assertEquals com control M. Precisamos criar o método converter e para isso clicamos em cima do nome e apertamos control 1. O método tem um atributo nome do tipo String e para o teste dar certo podemos simplesmente colocar o retorno desejado. Mas uma forma melhor de fazer isso é montar a string usando o método substring. O método substring funciona com o valor de início (zero indica o primeiro caractere) e o valor de limitação de caracteres. Caso o valor de limitação não seja usado a substring conterá todos os caracteres após a posição indicada. E para deixar o código mais eficaz, usamos uma anotação before para conter a instanciação da variável que é usada nos dois testes, depois de declará-la no início da classe. Aproveitamos para apagar o primeiro teste porque ele já não faz mais nada. Testamos e tudo funciona. Forçamos um erro criando então um novo teste deveConverterNomeSimplesMisturadoMaiusculoEMinusculo com a mesma declaração do teste anterior mas alterando a escrita no método converter para "lIOnel". Para consertar basta acrescentar o método .toLowerCase() no final do método converter na classe CamelCaseConverter.
Criamos então um novo projeto camel-case-2 usando o Maven. Nas configurações escolhemos a opção para criar um projeto simples e apertamos next. O Group Id é com.gft e o Artifact Id é camel-case-2. A versão é 1.0.0 - snapshot. O packaging fica jar mesmo. Abrimos então o pom.xml e acrescentamos as propriedades e plugins necessários. E assim temos duas formas de começar o projeto com testes.

2.1) Como começou o TDD: http://wiki.c2.com/?TenYearsOfTestDrivenDevelopment

2.2) Aprenda o ciclo vermelho-verde-refatora: essa ordem significa criar os testes primeiro, depois consertá-los para que deem certo e a barra do JUnit fique verde e então refatorar o código. Vamos fazer um projeto de teste de pedidos para colocar em prática os usos de testes. Abrimos um projeto Java novo chamado pedido-vendas, a exemplo do projeto anterior. Abrimos então uma classe PedidoTest no pacote com.gft, na pasta test. Escrevemos então o primeiro teste que é um método deveCriarUmPedido para instanciar uma classe Pedido a partir de uma variável pedido. O STS vai pedir que construa o caminho do JUnit e para abrir uma classe pedido. Fazemos isso no pacote src. Rodamos o teste e então vamos a refatoração. Como não há nada para refatorar no momento fazemos um segundo teste, devePermitirAdicionarUmItemNoPedido, com o método adicionarItem e 3 atributos: descrição, preço e quantidade. O STS vai pedir para criar o método. Rodamos o teste ele passa. Vamos então refatorar as linhas duplicadas. Colocamos uma anotação before no início da classe, criamos nela o método setup e incluímos a instanciação do pedido dentro dela. Criamos a variável privada do tipo pedido antes do before. Retiramos as linhas duplicadas e o primeiro teste que ficou redundante. Criamos mais um teste com um método chamado deveCalcularValorTotalParaPedidoVazio. Dentro dele usamos um assertEquals com o valor esperado de 0.0, o valor real representado pelo método valorTotal da classe Pedido, além do delta de margem de erro de 0.0001. O STS vai pedir para criar um método na classe, usamos control 1 pra isso. No método corrigimos Object para Double e retornamos 0.0.  Criamos outro teste com um método chamado deveCalcularValorTotalEDescontoParaPedidoVazio, com o mesmo conteúdo do anterior, mais um assertEquals para o desconto. Criamos então o método desconto na classe Pedido. Vamos então à refatoração, eliminando o teste deveCalcularValorTotalParaPedidoVazio porque ele já está previsto no que foi criado por último. selecionamos então o valor esperado do assertEquals no método deveCalcularValorTotalEDescontoParaPedidoVazio e clicando no botão direito  escolhemos Refactor > Extract Local Variable, chamando a variável de valorTotal. O STS cria a variável local valorTotal do tipo Double e nós criamos mais uma variável desconto do tipo Double também, as duas atribuídas a 0.0. Mudamos o primeiro atributo do segundo assertEquals para desconto. Aí selecionamos as duas linhas dos assertEquals que acabamos de mudar e com o botão direito selecionamos Refactor > Extract Method e escolhemos o nome assertResumoPedido. Aí clicamos no primeiro atributo do assertResumoPedido e com o botão direito selecionamos Refactor > Inline, fazendo a mesma coisa com o segundo atributo. Isso fez o STS criar o método detalhado do assertResumoPedido, no final da classe e o recortamos e copiamos logo abaixo do bloco da anotação before. Criamos então um novo teste deveCalcularResumoParaUmItemSemDesconto com um método adicionarItem da classe pedido e os atributos "Sabonete", 5.0, 5, além de incluir o assertResumoPedido com os atributos 25.0 e 0.0 no final. Testamos tudo e temos a faixa vermelha, então precisamos melhorar o código. Então na classe pedido criamos duas variáveis privadas de tipo Double, valorTotal e desconto. Arrumamos o método adicionarItem incluindo uma atribuição de valorUnitário * quantidade ao valorTotal. Retornamos no método valorTotal a variável valorTotal e no método desconto a variável desconto. Apesar de o padrão já ser inicializar as variáveis Double com 0, deixamos explícito atribuindo 0 às duas variáveis privadas. Testamos tudo e funciona. Refatoramos a classe Pedido criando uma classe nova. Para isso selecionamos as variáveis de atributo no método adicionarItem com o botão direito e selecionamos Refactor >  Introduce Parameter Object, inserindo o nome ItemPedido como  nome da classe e itemPedido como parâmetro, além de marcar Create getters e Create setters. Isso faz com que o STS, além de criar uma nova classe, refatore o código para incluir a nova variável itemPedido. 

2.3) Um passo de cada vez - baby steps: Na classe pedido teste criamos um novo teste deveCalcularResumoParaDoisItensSemDesconto o método adicionarItem da classe Pedido repetido duas vezes com atributos diferentes e o método assertResumoPedido com atributos 30.0 e 0.0, representando o total dos dois itens anteriores. Rodamos o teste novamente e não funciona. É preciso acrescentar um + à atribuição no método adicionarItem da classe Pedido. Também vamos refatorar essa classe declarando variáveis no início e removendo a atribuição de valorTotal do método adicionarItem e acrescentando no método valorTotal. Com uma das variáveis mudamos adicionarItem com um método add. Alteramos também a operação do método valorTotal atribuindo o método stream do Java 8 com mapeamento em um lambda, somando tudo ao final e colocando tudo direto no return, reduzindo o método. Na classe PedidoTest adicionarmos o teste deveAplicarDescontoNa1aFaixa. Dentro dele adicionamos um item e usamos o assertResumoPedido. Para refatorar código criamos uma classe ResumoPedido na pasta src.  Aí na classe Pedido criamos um método resumo com retorno do tipo  ResumoPedido. Trazemos a declaração dentro do método valorTotal para dentro do método resumo atribuindo a uma variável valor total do tipo double. Abaixo dela criamos uma variável local desconto do tipo double atribuída a 0. Incluindo também uma declaração if se o valor total for maior que 300 para aplicar desconto de 25%. Na classe ResumoPedido  declaramos as variáveis privadas do tipo Double valorTotal e desconto e criamos construtor, getters e setters. Na classe Pedido  eliminamos os dois métodos valor total e desconto. Criamos o retorno de ResumoPedido como new ResumoPedido. O teste vai quebrar então corrigimos o método assertResumoPedido, adicionando a declaração da variável resumoPedido do tipo ResumoPedido, atribuindo ao método resumo da classe Pedido. Nos dois assertEquals alteramos o segundo atributo de pedido para resumoPedido, usando o getter correspondente ao que antes era o método. Adicionamos então o novo teste deveAplicarDescontoNa2aFaixa, similar ao anterior, só que com dois produtos. Precisamos então alterar a condição if no método resumo na classe Pedido para incluir a faixa de desconto para valores maiores que 800, sem esquecer de limitar o valor a menor que 800 da primeira condição. Acrescentamos o teste  deveAplicarDescontoNa3aFaixa nas mesmas condições que o anterior, com mais itens e desconto maior. Também alteramos as condições do if na classe Pedido para contemplar o desconto de 8% para valores acima de 1000.

2.4) Melhorando o Design de Classe: Na classe Pedido vamos alterar a parte com ifs usando o design pattern de chain of responsibility. Para isso criamos uma nova classe abstrata CalculadoraFaixaDesconto num pacote desconto da pasta src. Dentro dessa classe criamos um construtor CalculadoraFaixaDesconto com a variável proximo do tipo CalculadoraFaixaDesconto como atributo. Criamos então um método público desconto com retorno do tipo double e a variável valorTotal do tipo double como atributo. Dentro do método criamos uma variável desconto do tipo double, atribuída ao método calcular com atributo valorTotal. Abaixo dele criamos um método protegido calcular com retorno de uma variável double abstrata e uma variável valor total do tipo double como atributo. Dentro do método desconto acrescentamos um if com a condição desconto igual a -1,  dentro dele um return com o método desconto e atributo valor total, e o retorno final do método é desconto. Abrimos então uma nova classe dentro do pacote desconto chamada CalculadoraDescontoTerceiraFaixa estendendo a classe CalculadoraFaixaDesconto. Criamos então um construtor com superclasse usando o atalho alt shift s. Acrescentamos dentro do @Override o if referente à terceira faixa de desconto que estava na classe Pedido, alterando a variável desconto direto para o return. Como o if só tem uma linha de bloco não é preciso usar chaves. Também mudamos o retorno final do método de zero para -1. Criamos então a classe CalculadoraDescontoSegundaFaixa estendendo a classe CalculadoraFaixaDesconto e um construtor com superclasse. Acrescentamos dentro do @Override o if referente à segunda faixa de desconto que estava na classe Pedido, alterando a variável desconto direto para o return e o retorno final do método de zero para -1. Também criamos a classe CalculadoraDescontoPrimeiraFaixa estendendo a classe CalculadoraFaixaDesconto e um construtor com superclasse. Acrescentamos dentro do @Override o if referente à segunda faixa de desconto que estava na classe Pedido, alterando a variável desconto direto para o return e o retorno final do método de zero para -1. E finalmente criamos a classe SemDesconto estendendo a classe CalculadoraFaixaDesconto e um construtor com superclasse, mantendo o retorno final do método como zer, já que não se aplica desconto nesse caso. Dentro da classe Pedido criamos uma variável privada CalculadoraFaixaDesconto do tipo calculadoraFaixaDesconto e criamos um construtor para essa variável. Dentro do método resumo comentamos a sequência de ifs usando control shift C. Dentro do mesmo método atribuímos à variável desconto calculadoraFaixaDesconto com o método desconto e atributo valorTotal. Na classe PedidoTest, dentro da anotação before acrescentamos no método setup uma variável calculadoraFaixaDesconto do tipo CalculadoraFaixaDesconto e atribuímos a instanciação aninhada das classes de desconto que criamos, incluindo cada uma como atributo da anterior até chegar na última, SemDesconto, cujo atributo é null. Na instância de pedido que está na sequência colocamos calculadoraFaixaDesconto como atributo. Testamos e tudo funciona. Agora podemos apagar a sequência de ifs dentro do método resumo da classe pedido e tudo continua funcionando.

2.5) O que testar agora: Devemos analisar o código e ver o que vale a pena testar ou não. Sempre é possível seguir um caminho e, se o processo se tornar complexo demais, voltar atrás e tomar outra direção. A área de teste gira em torno dessa análise constante de possibilidades que geram mais ganho e menos perda em relação aos esforços dispendidos e resultados alcançados.

2.6) E se criarmos os testes depois do código: Quem faz testes depois do código normalmente vai investir tempo na produção e depois o mesmo tanto ou mais em testes. Já quem usa TDD tem esse tempo distribuído nas duas partes durante todo o desenvolvimento , e até mesmo diminui o tempo considerando que é preciso menos debug ao final. No início pode parecer que é mais tempo até adquirir fluência no tdd, mas com a prática esse tempo vai diminuindo. Além disso, quando se escreve o teste depois do código pronto é possível deixar passar alguma coisa, já no TDD, isso não acontece, porque as coisas são feitas simultaneamente.

3.1) O código do teste também é importante: Vamos então analisar o código dos testes e como eles são compostos. Existem três partes principais: o cenário, a ação e a validação (verificação). Uma biblioteca interessante para ajudar nas validações é: https://github.com/hamcrest/JavaHamcrest e seu tutotial está em http://hamcrest.org/JavaHamcrest/tutorial.

3.2) Removendo duplicações: Podemos apagar o método devePermitirAdicionarUmItemNoPedido na classe PedidoTest, pois já não precisamos mais dele. E de resto, sempre devemos deixar os testes mais simples possível, sem deixar nada duplicado desnecessariamente.

3.3) Defina bons nomes: É preciso definir bons nomes para os métodos. Normalmente métodos públicos tem nomes mais curtos e os privados podem ter nomes maiores. Mas nos testes é bom usar nomes bem explicativos, mesmo que sejam maiores. Caso prefira não usar camelCase, é possível separar as palavras por underscore. 

3.4) O padrão Test Data Builders: Para começar criamos uma nova classe PedidoBuilder na pasta test > com.gft.  Ela vai facilitar na criação do cenário da classe para a qual o builder é construído. Começamos removendo o conteúdo do método setup da classe PedidoTest. Na classe PedidoBuilder criamos uma variável privada chamada instancia do tipo Pedido. Criamos um construtor e colocamos o conteúdo do método setup da classe PedidoTest, trocando a variável pedido de instanciação para o nome instancia. Em PedidoTest, trocamos a declaração da variável pedido do tipo Pedido para PedidoBuilder e dentro da anotação before instanciamos o PedidoBuilder a uma variável pedido. Em PedidoBuilder acrescentamos um método público comItem de retorno PedidoBuilder e atributos valorUnitario de tipo double e quantidade do tipo int. Dentro dele a variável instancia com o método adicionarItem instanciando ItemPedido com os atributos string “Gerado”, variável valorUnitario e variável quantidade. E o retorno final é this. Em PedidoTest, no método deveCalcularResumoParaUmItemSemDesconto, alteramos a chamada do método adicionarItem para comItem, deixando apenas os atributos necessários. No método deveCalcularResumoParaDoisItensSemDesconto, como são 2 itens é possível colocá-los em sequência separando por pontos. Fazemos o mesmo em deveAplicarDescontoNa1aFaixa, deveAplicarDescontoNa2aFaixa e deveAplicarDescontoNa3aFaixa. Aí no PedidoBuilder criamos mais um método público construir do tipo Pedido e retornamos instancia. Em PedidoTest, no método assertResumoPedido podemos acrescentar construir na atribuição pedido.resumo(). Testamos e tudo funciona.

3.5) Atenção às asserções: O ideal é evitar muitas asserções no final de cada teste. Uma forma de fazer isso para o método assertResumoPedido em PedidoTest é ir na classe ResumoPedido e gerar o hashCode() e o equals() de desconto e valorTotal. Em PedidoTest alteramos as linhas de assertEquals para apenas uma, usando como valor esperado uma instância de ResumoPedido com atributos valor total e desconto, e como valor real, resumoPedido. Para melhorar o resultado dos testes acrescentamos também um método toString ao ResumoPedido.

3.6) Testando exceções: Vamos criar em PedidoTest um teste com retorno nulo chamado nãoAceitarPedidosComItensComQuantidadesNegativas que lança uma exceção e contém o método comItem da variável pedido ,atributos 0.0 e -10. Acrescentamos ao lado da anotação test, entre parênteses o termo expected igual a QuantidadeItensInvalidaException.class (sem espaços dentro dos parênteses). Criamos então no pacote src uma classe com esse nome estendendo RuntimeException. Em Pedido, no método adicionarItem, acrescentamos uma condição if para lançar uma exceção QuantidadeItensInvalidaException se a quantidade do item do pedido for menor que zero. Testamos e tudo funcionando. Refatoramos a condição em um método validarQuantidadeItens (Extract method) e posicionamos o novo método acima do método adicionarItem. 

4.1) Identificando responsabilidades de uma classe:  É preciso que as classes sejam coesas e não contenham mais do que o necessário, e é para isso que serve a identificação de responsabilidades. Devemos dividir as classes para cada uma fazer apenas pequenas coisas. Os testes ajudam a criar esse cenário. Quando a implementação de um teste fica difícil, isso é um sinal de que há um problema de design no código. Vamos criar um sistema de passagem aérea com regras para passageiros para exemplificar. A primeira regra é que passageiros do tipo gold têm desconto de 15% em passagens de mais de R$ 500, senão o desconto é de 10%. A segunda regra é que passageiros do tipo silver têm desconto de 10% em passagens de mais de R$ 700, senão o desconto é de 6%. Criamos então um projeto novo, já com JUnit, chamado passagem-aerea, com um pacote model dentro da pasta src e nele três classes: Passageiro, TipoPassageiro e Voo. Na classe Passageiro temos duas variáveis: nome, do tipo String, privada; e tipo do tipo TipoPassageiro, também privada, além do construtor, getters e setters. A classe TipoPassageiro é do tipo enum e contém os valores GOLD e SILVER. A classe Voo tem três variáveis: origem, do tipo string, privada; destino, do tipo string, privada e preço, do tipo double, privada, além do construtor, getters e setters. Não é preciso testar nada disso, então vamos ao pasta test e abrimos uma classe PrecoPassagemServiceTest dentro de um pacote service. Dentro dela criamos o teste deveCriarPrecoPassagemService escrevendo test e control espaço para agilizar a digitação. Dentro dele instanciamos a variável precoPassagemService do tipo PrecoPassagemService. Criamos então a classe PrecoPassagemService dentro da pasta src no pacote service, clicando em cima do nome e apertando control 1. Testamos e tudo funciona.  Criamos mais um teste chamado devePermitirChamarCalculoDoValor instanciando a variável precoPassagemService do tipo PrecoPassagemService. Instanciamos a variável passageiro do tipo Passageiro com atributos “João” e TipoPassageiro.GOLD. Instanciamos a variável voo do tipo Voo com atributos “Curitiba”, “Belo Horizonte” e 400.0 tudo que ele podia ele não faz o que eu quero. Dentro dele criamos uma variável valor do tipo double atribuída ao método calcular de precoPassagemService com os atributos passageiro e voo. Uso control shift O para importar as classes necessárias. Na classe PrecoPassagemService criamos o método calcular de retorno double com atributos passageiro do tipo Passageiro e voo do tipo Voo, com retorno final 0. Começamos a refatoração em PrecoPassagemServiceTest criando uma variável privada precoPassagemService do tipo PrecoPassagemService. Colocamos uma anotação before e no método nulo setup instanciamos precoPassagemService para poder remover essa linha dos testes abaixo. Com isso o primeiro teste já pode ser eliminado pois ele só fazia isso. Criamos mais um teste chamado deveCalcularValorPassagemParaPassageiroGold_ComValorAbaixoDoLimite e copiamos as instâncias do teste anterior. Incluímos um assertEquals seguindo as regras do projeto , ou seja, 90.0, a variável valor, e o delta 0.0001. Na classe PrecoPassagemService incluímos no método calcular uma condição if e métodos getter para conter o tipo do passageiro usando o método equals, já que é uma variável do tipo string, e retornar o preço do voo x 0.9 , o que  equivale a 10% de desconto. Testamos e tudo funciona. Podemos remover o teste devePermitirChamarCalculoDoValor pois já está sendo chamado. Criamos um novo teste deveCalcularValorPassagemParaPassageiroGold_ComValorAcimaDoLimite, copiando o conteúdo do teste anterior e alterando os atributos para corresponderem à regra. N vamos lá entãoa classe PrecoPassagemService alteramos a condição para incluir o segundo teste. Refatoramos os testes clicando com o botão direito no primeiro atributo do assertEquals e escolhendo a opção Refactor > Extract Local Variable colocando o nome como “esperado”. Selecionamos as linhas de declaração da variável valor e do assertEquals. Clicando com o botão direito nas linhas selecionadas, escolhemos a opção Refactor > Extract Method e colocamos o nome assertValorPassagem. Clicamos com o botão direito na variável esperado que é atributo do método e escolhemos Refactor > Inline. Arrastamos o novo método para cima, posicionando-o logo abaixo da anotação before. Copiamos a linha com o novo método para o outro teste que usa as mesmas condições. Testamos e tudo funciona. Criamos um novo teste deveCalcularValorPassagemParaPassageiroSilver_ComValorAbaixoDoLimite e copiamos as condições dos testes anteriores alterando segundo as regras. Na classe PrecoPassagemService alteramos o if para incluir em um else if as novas condições do passageiro SILVER. Abaixo das condições lançamos uma exceção TipoPassageiroInvalidoException e criamos a classe para contê-la no pacote service e estendendo RuntimeException. Testamos e tudo funciona. Implementamos o teste deveCalcularValorPassagemParaPassageiroSilver_ComValorAcimaDoLimite de acordo com as regras. Testamos e tudo funciona.

4.2) Refatorando para aumentar a coesão: Começamos criando uma nova interface dentro do pacote service chamada CalculadoraPrecoPassagem para definir o comportamento que todas as classes devem seguir. Dentro dela criamos um método calcular com retorno double e atributo voo do tipo Voo. Aí criamos uma classe PrecoPassagemGold  que implemente CalculadoraPrecoPassagem, dentro do pacote service também. Ela já traz os métodos da interface e incluímos  dentro dele a primeira condição if da classe PrecoPassagemService. Extraímos os métodos dos dois retornos com retorno double e nomes calcularValorAbaixoDoLimite e calcularValorAcimaDoLimite com atributo voo de tipo Voo. Criamos uma classe PrecoPassagemSilver  que implemente CalculadoraPrecoPassagem, dentro do pacote service também. Incluímos  dentro dele a segunda condição if da classe PrecoPassagemService. Testamos e tudo funciona. No enum TipoPassageiro  criamos uma variável calculadoraPrecoPassagem do tipo CalculadoraPrecoPassagem e um construtor para ela. Também instanciamos os valores de enum GOLD e SILVER com as classes PrecoPassagemGold e PrecoPassagemSilver que criamos. E finalmente acrescentamos um getter chamado getCalculadora(). Em PrecoPassagemService removemos as condições if no método calcular e o lançamento de exceção e acrescentamos um retorno final da variável passageiro com os métodos getTipo e  getCalculadora sem atributos e o método calcular com atributo voo. Testamos e tudo funciona.

4.3) Usando Mock Objects:  Abrimos um projeto no Maven com o nome pedido-vendas-mock. Acrescentamos o JUnit e o Mockito no pom.xml. Organizamos os seguintes pacotes e classes na pasta src/main/java: com.gft.tdd.email (com a classe NotificationEmail), com.gft.tdd.model (com as classes Cliente e Pedido), com.gft.tdd.model.builder (com a classe  PedidoBuilder), com.gft.tdd.repository (com a classe  Pedidos), com.gft.tdd.sms (com a classe NotificationSms).

4.4) 

4.5) Próximos passos - mais mock: Criamos um enum StatusPedido no pacote tdd.model.  Dentro dele declaramos dois valores: PENDENTE e PAGO.  Em PedidoServiceTest criamos um novo teste chamado devePagarPedidoPendente. Dentro dele criamos uma variável codigo do tipo Long atribuída a 135L. Criamos uma variável pedidoPago do tipo Pedido atribuída ao método pagar de pedidoService que criamos usando control 1 em cima do método. Incluímos no teste um assertEquals com a variável esperada StatusPedido.PAGO e a variável e real com o status de pedidoPago com um getter, que ainda será criado. Na classe PedidoService criamos uma variável privada chamada pedidos do tipo Pedidos e a incluímos no construtor. Além disso é preciso alterar a instanciação dentro da anotação before em PedidoServiceTest. No repositório Pedidos criamos um método buscarPeloCodigo com retorno do tipo Pedido e o atributo codigo do tipo Long que terá um retorno final de instanciação de Pedido(). Voltando à classe PedidoService, incluímos no método pagar uma variável pedido do tipo Pedido atribuída a variável pedidos com o método buscarPeloCodigo e atributo codigo. Acrescentamos abaixo um if com uma condição negativa de pedido com método getStatus para comparar o StatusPedido.PENDENTE usando equals e lançar uma exceção StatusPedidoInvalidoException, que criamos com control 1 dentro do mesmo pacote service. Abaixo do if incluímos a variável pedido com o método setStatus com o atributo StatusPedido.PAGO e no retorno final, a variável pedido.
